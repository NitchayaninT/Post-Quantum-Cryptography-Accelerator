Pretum 14/7/25
Topic : Implementation Analysis of SHAKE128 Using the Keccak Code Package (XKCP)
Authors : Guido Bertoni, Joan Daemen, Seth Hoffert, Michaël Peeters1, Gilles Van Assche1 and Ronny Van Keer (Keccak Team)
github : https://github.com/XKCP/XKCP.git
source : https://keccak.team/software.html

The eXtended Keccak Code Package or XKCP gathers different free and open-source implementations of Keccak schemes. 
Such as the SHAKE extendable-output functions, written in C and assembly

In Keccak dir :
SimpleFIPS202.c	Implements shake128(), shake256(), sha3_256() — this is the high-level, clean SHAKE interface
SimpleFIPS202.h	Header with function declarations

Subtopics :
1. What SHAKE is (brief) 
    - Member of SHA3
    - Output length is variable
    - Based on Keccak-f[1600]
2. How it works conceptually (brief)
    - Diagram of sponge model:
        Absorb (input)
        Pad
        Permute (Keccak rounds)
        Squeeze (output)
    - Highlight:
        RATE = 1344 bits
        CAPACITY = 256 bits
        Total state = 1600 bits
3. How it is implemented step-by-step in C
    - Introduce to github repo 
    - Implement in Keccak Dir
    - SimpleFIPS202.c : This file defines the standard API used in cryptographic software, 
    and simply passes arguments to the lower-level implementation.
    - KeccakSponge.c / KeccakSponge.inc : These files contain the core sponge logic, such as:
    Initialization, Absorption of input, Padding, Squeezing output
    --DETAILS--

    -- Inside Sponge Function --

    - The function KeccakWidth1600_Sponge() in SimpleFIPS is not manually written, 
    but auto-generated using macros in a file KeccakSponge.h
        - XKCP_DeclareSpongeFunctions(KeccakWidth1600) in KeccakSponge.h 

    - This expands to functions like:
        KeccakWidth1600_SpongeInitialize(...)
        KeccakWidth1600_SpongeAbsorb(...)
        KeccakWidth1600_SpongeSqueeze(...), which are in KeccakSponge.inc

    - Inside KeccakSponge.inc, these functions are implemented using:
        An internal SpongeInstance struct
        A loop that updates the 1600-bit Keccak state
    This is the main logic block that performs the sponge construction. 

    -- Keccak Sponge Data Structure --

    - In KeccakSponge.h @#define XKCP_DeclareSpongeStructure(prefix, state_t)
    - prefix is just a This is just a name. It's a label used to prefix the function/struct names for SHAKE128/SHAKE256
    - state_t is defined in lib/low/KeccakP-1600/ref-32bits/KeccakP-1600-SnP.h in the LOW level struct
    - The XKCP_DeclareSpongeStructure triggers the high level struct which includes :
        typedef struct {
        KeccakP1600_plain32_state state;   // ← LOW level struct
        unsigned int rate;                 // e.g., 1344 for SHAKE128
        unsigned int byteIOIndex;         // internal byte pointer
        int squeezing;                    // 0 = absorb, 1 = squeeze
    } KeccakWidth1600_SpongeInstance;

    - the actual struct(low level) is inside the file called lib/low/KeccakP-1600/ref-32bits/"KeccakP-1600-SnP.h"
    - The “ref-32bits” version is the default, portable, clean implementation used when no architecture-specific optimization is selected.
    typedef struct {
        uint32_t A[50];
    } KeccakP1600_plain32_state;
    - This struct defines the internal state of Keccak-f[1600] for the 32-bit, bit-interleaved implementation.
        Details:
        - A[50] → 25 lanes × 2 = 50 values
        - Each lane in Keccak is 64 bits
        - This 32-bit version splits each 64-bit lane into two 32-bit words:
            - even bits and odd bits (interleaved form)
        So this represents the full 1600-bit Keccak state (The Keccak state is 1600 bits = 25 lanes × 64 bits)
    Summary : The macro XKCP_DeclareSpongeStructure(KeccakWidth1600, KeccakP1600_state) 
    creates a sponge instance named KeccakWidth1600_SpongeInstance. 
    The prefix KeccakWidth1600 is a naming convention, while KeccakP1600_state is a typedef 
    for the actual 1600-bit Keccak state used inside the sponge. 
    This allows the library to create modular sponge instances for different Keccak widths 
    (e.g., 200, 400, 800, 1600) using the same macro template.

    -- Keccak Permutation --
    - Then, Keccak Permutation logic : In KeccakP-1600/ dir
        - Contains KeccakP-1600-reference.c, KeccakP-1600-reference.h
        - KeccakP1600_Permute_24rounds(state)
        - logic is in KeccakP1600_PermutationOnWords(...)

    - SimpleFIPS202.c → KeccakWidth1600_Sponge(...)
                      → [via macros in KeccakSponge.h]
                      → KeccakSponge.c calls KeccakF1600_StatePermute()
                      → KeccakP‑1600/KeccakP‑1600‑reference.c

4.Summary / Takeaways
SHAKE128 is based on flexible sponge construction
XKCP modularizes the code using macros and prefixes
Each phase in SHAKE matches one part of the FSM in hardware
This understanding helps in future translation to Verilog usage
“Each SHAKE128 phase—absorb, permute, and squeeze—maps directly 
to a finite state machine (FSM) in hardware, 
making the software logic highly relevant to Verilog-based FPGA implementations.”
